# Membangun Bot Pertamamu

Selamat! Anda telah menuntaskan seluruh materi teori dalam buku ini. Namun, di pasar kripto yang beroperasi 24/7 dengan volatilitas tinggi, mata manusia tidak akan sanggup memantau peluang yang muncul hanya dalam hitungan detik.

Kecepatan adalah mata uang utama dalam arbitrase. Dalam bab penutup ini, kita akan mentransformasi pengetahuan Anda menjadi sebuah alat otomatis: **Bot Arbitrase Segitiga**. Kita akan menggunakan Python sebagai bahasa pemrograman, CCXT sebagai jembatan ke bursa, dan AI sebagai asisten teknis Anda.

## Persiapan Infrastruktur (The Toolbox)

Sebelum masuk ke kode, siapkan ekosistem pengembangan Anda:

1.  **Python 3.10+**: Bahasa yang ramah pemula namun sangat bertenaga untuk data keuangan.

2.  **Visual Studio Code (VS Code)**: Editor teks standar industri.

3.  **Library CCXT**: Library wajib yang menyatukan ratusan API bursa (Binance, Bybit, dll) ke dalam satu format perintah yang seragam.

4.  **Python-dotenv**: Untuk menyembunyikan kunci rahasia (API Key) Anda dari publik.

5.  **Akun Bursa & API Key**: Disarankan menggunakan **Testnet** (akun demo) terlebih dahulu untuk menghindari risiko kehilangan modal saat belajar.

## Strategi Prompt Engineering: Memandu AI Membangun Bot

Jangan meminta AI membuat bot dalam satu perintah besar. Gunakan metode **Modular Prompting** agar kode yang dihasilkan lebih rapi dan minim *bug*. Berikut urutan *prompt* yang bisa Anda gunakan pada Gemini atau ChatGPT:

-   **Prompt Fondasi:** *"Saya ingin membangun bot Triangular Arbitrage di Binance menggunakan Python dan CCXT. Tolong buatkan struktur Class utama yang bisa membaca API Key dari file .env."*

-   **Prompt Logika:** *"Tambahkan fungsi untuk memantau harga bid/ask dari tiga pasangan koin (misal: BTC/USDT, ETH/BTC, dan ETH/USDT) secara simultan."*

-   **Prompt Eksekusi:** *"Buat fungsi perhitungan profit yang sudah menyertakan potongan fee transaksi sebesar 0.1% di setiap langkahnya."*

## Implementasi Kode Utama

Berikut adalah kode bot yang telah kita optimasi. Silakan salin ke file bernama `bot_arbitrase.py`.

``` python
import ccxt
import time
import os
from dotenv import load_dotenv

# 1. LOAD KONFIGURASI KEAMANAN
load_dotenv()
API_KEY = os.getenv('BINANCE_API_KEY')
API_SECRET = os.getenv('BINANCE_API_SECRET')

class ArbitrageBot:
    def __init__(self):
        # Inisialisasi Bursa
        self.exchange = ccxt.binance({
            'apiKey': API_KEY,
            'apiSecret': API_SECRET,
            'enableRateLimit': True,
        })
        self.investment_amount = 100  # Modal awal (USDT)
        self.min_profit_target = 0.2  # Target profit minimal (%)
        self.fee = 0.001              # Estimasi fee 0.1% per transaksi

    def get_prices(self):
        """Mengambil data harga bid/ask untuk rute segitiga"""
        try:
            # Rute: USDT -> BTC -> ETH -> USDT
            tickers = self.exchange.fetch_tickers(['BTC/USDT', 'ETH/BTC', 'ETH/USDT'])
            return {
                'step1': tickers['BTC/USDT']['ask'], # Harga beli BTC
                'step2': tickers['ETH/BTC']['ask'],  # Harga beli ETH menggunakan BTC
                'step3': tickers['ETH/USDT']['bid']  # Harga jual ETH ke USDT
            }
        except Exception as e:
            print(f"Gagal mengambil harga: {e}")
            return None

    def calculate_profit(self, prices):
        """Menghitung potensi hasil akhir"""
        # Langkah 1: USDT ke BTC (Beli di harga Ask)
        btc_bought = (self.investment_amount / prices['step1']) * (1 - self.fee)
        
        # Langkah 2: BTC ke ETH (Beli di harga Ask)
        eth_bought = (btc_bought / prices['step2']) * (1 - self.fee)
        
        # Langkah 3: ETH kembali ke USDT (Jual di harga Bid)
        final_usdt = (eth_bought * prices['step3']) * (1 - self.fee)
        
        profit_pct = ((final_usdt - self.investment_amount) / self.investment_amount) * 100
        return final_usdt, profit_pct

    def run(self):
        print("--- Bot Arbitrase Aktif & Memindai Peluang ---")
        while True:
            prices = self.get_prices()
            if prices:
                final_amount, profit_pct = self.calculate_profit(prices)
                
                if profit_pct > self.min_profit_target:
                    print(f"!!! PELUANG PROFIT: {profit_pct:.3f}% | Hasil: {final_amount:.2f} USDT")
                else:
                    print(f"Scanning... Profit saat ini: {profit_pct:.3f}%", end='\r')
            
            time.sleep(2) 

if __name__ == "__main__":
    bot = ArbitrageBot()
    bot.run()
```

------------------------------------------------------------------------

## Bedah Kode: Memahami Setiap Baris

Untuk menjadi pengembang bot yang handal, Anda harus memahami logika di balik kode tersebut. Berikut adalah penjelasannya:

### A. Library dan Keamanan (`Imports & Dotenv`)

-   **`import ccxt`**: Ini adalah "jembatan" utama. CCXT memungkinkan bot berbicara dengan API bursa (Binance, Bybit, dll) tanpa kita harus menulis kode API manual yang rumit.
-   **`load_dotenv()`**: Baris ini memerintahkan Python untuk mencari file tersembunyi bernama `.env`. Di sanalah kita menyimpan `API_KEY` agar tidak terlihat oleh orang lain. **Jangan pernah menulis API Key langsung di dalam script utama.**

### B. Inisialisasi (`__init__`)

-   **`enableRateLimit: True`**: Setiap bursa punya aturan seberapa cepat kita boleh meminta data. Jika terlalu cepat, IP Anda akan diblokir. Fitur ini memastikan bot kita "sopan" dan mengikuti aturan bursa secara otomatis.
-   **`self.investment_amount`**: Kita menetapkan modal virtual untuk simulasi hitungan.

### C. Pengambilan Data (`get_prices`)

-   **Ask vs Bid**: Ini adalah bagian paling krusial.
    -   Saat kita ingin **membeli**, kita melihat harga **Ask** (harga terendah yang diminta penjual).
    -   Saat kita ingin **menjual**, kita melihat harga **Bid** (harga tertinggi yang ditawarkan pembeli).
-   Bot mengambil tiga harga sekaligus untuk meminimalkan jeda waktu (latency).

### D. Logika Perhitungan Profit (`calculate_profit`)

Dalam arbitrase segitiga, kita melakukan "perjalanan" koin: 1. **Langkah 1**: Mengonversi USDT ke BTC. Rumus: `Modal / Harga Ask BTC`. 2. **Langkah 2**: Mengonversi BTC ke ETH. Rumus: `Jumlah BTC / Harga Ask ETH/BTC`. 3. **Langkah 3**: Mengonversi ETH kembali ke USDT. Rumus: `Jumlah ETH * Harga Bid ETH/USDT`. \* **Potongan Fee**: Di setiap langkah, kita mengalikan dengan `(1 - self.fee)`. Jika fee bursa 0.1%, maka kita hanya memiliki 99.9% dari aset asli setelah transaksi. Banyak pemula lupa menghitung ini dan akhirnya merugi.

### E. Siklus Berulang (`run`)

-   **`while True`**: Ini membuat bot berjalan selamanya sampai kita menghentikannya secara manual.
-   **`time.sleep(2)`**: Memberikan jeda 2 detik sebelum memindai ulang. Tanpa jeda, komputer Anda akan bekerja terlalu keras dan API bursa mungkin akan memutuskan koneksi Anda.

------------------------------------------------------------------------

## Tips Mengoptimalkan Bot dengan AI

Setelah memahami dasar-dasarnya, Anda bisa meminta bantuan AI untuk meningkatkan kemampuan bot ini dengan instruksi (prompt) berikut:

1.  **Menangani Error Koneksi**: *"Tambahkan logika 'retry' pada fungsi get_prices jika internet terputus agar bot tidak berhenti tiba-tiba."*
2.  **Logika Eksekusi Nyata**: *"Buat fungsi execute_trade yang menggunakan `create_order` dari CCXT untuk mengeksekusi tiga transaksi tersebut secara berurutan hanya jika profit \> 0.2%."*
3.  **Manajemen Slippage**: *"Modifikasi perhitungan agar menggunakan harga dari Order Book kedalaman 5, bukan hanya harga ticker terakhir."*

------------------------------------------------------------------------

## Penutup: Etika dan Disiplin

Arbitrase adalah tentang ketelitian. Dengan memahami setiap baris kode di atas, Anda bukan lagi sekadar pengguna, melainkan seorang **Arsitek Sistem**. Gunakan pemahaman ini untuk terus bereksperimen di akun demo sebelum benar-benar terjun ke pasar nyata.

**Selamat membangun dan teruslah belajar!**
